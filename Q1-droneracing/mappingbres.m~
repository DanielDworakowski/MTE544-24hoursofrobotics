% Occupancy Grid Mapping
clear; clc;

% Simulation time
Tmax = 150;
T = 0:Tmax;

% Initial Robot location
% x0 = [5 20 0]
% Robot motions
u = [3 0 -3 0;
     0 3 0 -3];
 ui=1;
% Robot sensor rotation command
w = 0.3*ones(length(T));

run('racing.m')
% map = map.';

x0 = [startpos ./ dxy -pi];

% Belief map
m = 0.5*ones(M,N);
L0 = log(m./(1-m));
L=L0;

% Sensor model parameters
meas_phi = linspace(deg2rad(-69/2), deg2rad(69/2), 128);
rmax = 10 / dxy; % Max range
rmin = 0.3 / dxy;
alpha = 1; % Width of an obstacle (Distance about measurement to fill in)
beta = 0.05; % Width of a beam (Angle beyond which to exclude) 

%State Initialization
x = zeros(3,length(T)+1);
x(:,1) = x0;
dt = 1/5; 


%% Main simulation
for t=2:length(T)
    % Robot motion
%     move = x(1:2,t-1) + u(:,ui);
%     if ((move(1)>M||move(2)>N||move(1)<1||move(2)<1) || (map(move(1),move(2))==1))
%         x(:,t) = x(:,t-1);
%         ui = mod(ui,4)+1;
%     else
%         x(1:2,t) = move;
%     end
%     x(3,t) = x(3,t-1) + w(t);
%    
%     x(:,t) = motModel(x(:,t-1), 1, deg2rad(30), dt);
    x(:,t) =  trajRoll(x(:,t - 1), m);
    % Generate a measurement data set
    meas_r = getranges(map, x(:,t),meas_phi,rmax, rmin);


    %% Map update
    measL = zeros(M,N);
    for i = 1:length(meas_phi)
        % Get inverse measurement model
        invmod = inversescannerbres(M,N,x(1,t),x(2,t),meas_phi(i)+x(3,t),meas_r(i),rmax);
        if (~isempty(invmod))
          for j = 1:length(invmod(:,1))
              ix = invmod(j,1);
              iy = invmod(j,2);
              il = invmod(j,3);
              % Calculate updated log odds
              L(ix,iy) = L(ix,iy) +log(il./(1-il))-L0(ix,iy);
              measL(ix,iy)= measL(ix,iy) +log(il./(1-il))-L0(ix,iy);
          end
        end
    end
    % Calculate probabilities
    m = exp(L)./(1+exp(L));
    invmod_T = exp(measL)./(1+exp(measL));

    %% Plot results
    
    % Map and vehicle path
    figure(1);clf; hold on;
    image(100*(1-map));
    colormap(gray);
    plot(x(2,1:t),x(1,1:t),'bx-')
    axis([0 N 0 M])

    % Inverse measurement model
    figure(2);clf; hold on;
    image(100*(invmod_T));
    colormap(gray);
    plot(x(2,t),x(1,t),'bx')
    for i=1:length(meas_r)
        plot( x(2,t)+meas_r(i)*sin(meas_phi(i) + x(3,t)),x(1,t)+meas_r(i)*cos(meas_phi(i)+ x(3,t)),'ko')
    end
    axis([0 N 0 M])
    %F2(t-1) = getframe;
    title('Measurements and inverse measurement model');

    % Belief map
    figure(3);clf; hold on;
    image(100*(m));
    colormap(gray);
    plot(x(2,max(1,t-10):t),x(1,max(1,t-10):t),'bx-')
    axis([0 N 0 M])
    %F3(t-1) = getframe;
    title('Current occupancy grid map')

end


function [x_plus] = motModel(x, v, theta, dt)
  if (abs(v) > 20)
    v = sign(v) * 20;
  end
  v = v / 0.1;
  x_plus = x; 
  x_plus(1) = x_plus(1) + v * cos(x(3)) * dt; 
  x_plus(2) = x_plus(2) + v * sin(x(3)) * dt; 
  x_plus(3) = theta;
end

function [x_new] = trajRoll(x_cur, map)
  dt = 1/5;
  uMin = [2 -2]; % bounds on inputs, [velocity, rotation rate]
  uMax = [2 2]; % bounds on inputs, [velocity, rotation rate]
  uR = uMax-uMin; % range of inputs
  sMin = 10; % steps to move
  sMax = 50; % steps to compute for rollout
  n_traj = 15; % number of trajectories to roll out
  score_step = inf;
  for i = 1:n_traj
      % Constant speed, linear distribution of turn rates
      input = [uR(1)/2+uMin(1) uR(2)*(i-1)/(n_traj-1)+uMin(2)];
      steps = sMax; 

      % Propagate Dynamics
      x = x_cur
      for j=2:steps
%           x(:, j) = x(:,j-1)+[input(1)*cos(x(3,j-1))*dt; input(1)*sin(x(3,j-1))*dt; input(2)*dt]
          x(:, j) = motModel(x(:, j-1), input(1), input(2), dt);
      end
      keep = map(uint32(x(1,:)), uint32(x(2,:)))

      if (sum(keep)==steps)
          plot(x(:,1),x(:,2),'g');
          % Score the trajectory
          togo_cur = norm(x(end,1:2)-xF);
          obs_dist = inf;
          for k = 1:nO
              obs_dist = min(obs_dist,Dist2Poly(x(end,1),x(end,2),obsEdges(((k-1)*4)+1:4*k,1),obsEdges(((k-1)*4)+1:4*k,2)));
          end
          obs_dist;
          score_cur = togo_cur - 0.1*obs_dist;
          if (score_cur < score_step)
              score_step = score_cur;
              x_new = x(:,sMin);
              x_plot = x;
          end
      else
          plot(x(:,1),x(:,2),'r');
      end
  end
  % Check if no progress is made
  if (x_new==x_cur)
      x_new(3)=x_new(3)-0.1;
  else
      plot(x_plot(:,1),x_plot(:,2),'b');
      plot(x_plot(end,1),x_plot(end,2),'bo');
  end
  drawnow;
end